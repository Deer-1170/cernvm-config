#!/bin/sh

# This script fetches the master data from the contextualization API. We expect the data (IP address so far)
# to be readily available. To ensure this, we do the blocking wait in the bootloader (waiting for the 'master_ready'
# field to appear)

############################################################
# CLUSTER CONTEXTUALIZATION SECTION

CLUSTER_SERVICE_URL_DEFAULT=https://cernvm-online.cern.ch
# This file has to be fetched by the cloudinit service and placed in the following location
CONTEXT_FILE=/var/lib/cloud/instance/user-data.txt
# amiconfig context file, we extract 'cvm_cluster_pin', 'cvm_cluster_master' and 'cvm_service_url' fields from there
AMI_CONTEXT_FILE=/mnt/.rw/context/user-data

# How many times we try to connect to the service
# A try every ~15s * 5 = ~1.25minutes
MAX_TRIES=5
# Sleep time in seconds between each try
SLEEP_TIME_BETWEEN_REQUESTS=15
# Key name under which the master stores its IP in the contextualization service
MASTER_IP_FIELD="master_ip"
# Item name in the context file (in the ucernvm section)
CLUSTER_MASTER_CONTEXT_FIELD="cvm_cluster_master"
CLUSTER_PIN_CONTEXT_FIELD="cvm_cluster_pin"
CLUSTER_SERVICE_URL_FIELD="cvm_service_url"
READY_STATUS_KEY_FIELD="master_ready"
# Pattern in the context file, which gets replaced by the fetched data
PLACECEHOLDER_REPLACEMENT=###MASTER_IP_PLACEHOLDER###

# Return cluster_pin from the context file
get_cluster_pin_from_context() {
    # Check if the context file has cluster_pin inside ucernvm section
    # sed prints all lines  in the [ucernvm-*] section, grep greps the cluster_pin line
    local PIN_LINE=
    PIN_LINE=$( sed -n '/\[ucernvm-begin\]/,/\[ucernvm-end\]/p' "$AMI_CONTEXT_FILE" 2>/dev/null | grep "$CLUSTER_PIN_CONTEXT_FIELD=" )
    if [ $? -ne 0 ]; then
        echo "" # Does not have cluster_pin
        return 1
    fi

    # Erase the first occurence of 'cluster_pin=' from the grepped pin line
    local CLUSTER_PIN=
    CLUSTER_PIN=$( echo "$PIN_LINE" | sed -e "s/$CLUSTER_PIN_CONTEXT_FIELD=//1" )

    echo "$CLUSTER_PIN"
}

# Return cluster contextualization URL: either from the context file or the default value
get_service_url() {
    # Check if the context file has cluster_service_url inside ucernvm section
    # sed prints all lines  in the [ucernvm-*] section, grep greps the cluster_pin line
    local URL_LINE=
    URL_LINE=$( sed -n '/\[ucernvm-begin\]/,/\[ucernvm-end\]/p' "$AMI_CONTEXT_FILE" 2>/dev/null | grep "$CLUSTER_SERVICE_URL_FIELD=" )
    if [ $? -ne 0 ]; then
        echo "$CLUSTER_SERVICE_URL_DEFAULT" # Does not have cluster_service_url, using default
        return 0
    fi

    # Erase the first occurence of 'cluster_service_url=' from the grepped pin line
    local SERVICE_URL=
    SERVICE_URL=$( echo "$URL_LINE" | sed -e "s/$CLUSTER_SERVICE_URL_FIELD=//1" )
    if [ "$SERVICE_URL" ]; then
        echo "$SERVICE_URL"
    else
        echo "$CLUSTER_SERVICE_URL_DEFAULT" # empty field, using default
    fi
}

# Create a marker file indicating that contextualization has been done
create_ci_marker_file() {
    touch /etc/cernvm/cloudinit-contextualized
}

# Check if marker file exists and context file exists
marker_file_exists() {
    if [ -f /etc/cernvm/cloudinit-contextualized -o ! -f "$CONTEXT_FILE" ]; then
        return 0
    else
        return 1
    fi
}


############################################################
# SLAVE PART

slave_contextualization() {
    local CLUSTER_PIN=
    CLUSTER_PIN=$( get_cluster_pin_from_context )
    if [ "x$CLUSTER_PIN" = "x" ]; then
        echo "Context file (cloud-init) does not have a cluster pin\n"
        return 0
    fi

    echo "Slave cluster contextualization: getting master keys"

    local SERVICE_URL=
    SERVICE_URL=$( get_service_url )

    local CURL_HEADERS="-H Accept:text/plain"
    # Output format: Content_of_the_reply\n\nstatus_code_number
    local CURL_CMD_TEMPLATE="curl -s -w \n\n%{http_code} -XGET"
    local CURL_CMD="$CURL_CMD_TEMPLATE $SERVICE_URL/api/clusters/$CLUSTER_PIN/keys/$MASTER_IP_FIELD $CURL_HEADERS"

    response=
    cnt=1
    while [ $cnt -le $MAX_TRIES ]; do
        response=$( $CURL_CMD )
        local status_code=
        status_code=$( echo "${response}" | tail -n 1 )  # get the last line with status code
        response=$( echo "${response}" | head -n -2 )  # get everything except the last line
        if [ "x$status_code" = "x200" ]; then
            break  # success
        fi
        echo "Try $cnt/$MAX_TRIES"
        cnt=$(($cnt+1))
        local rand=$( grep -m1 -ao '[0-9]' /dev/urandom | head -n1 ) # get 0-9
        sleep $(( $SLEEP_TIME_BETWEEN_REQUESTS + $rand )) #add 10s jitter
    done

    if [ $(($cnt-1)) -eq $MAX_TRIES ]; then  # cnt-1 because of upper while condition: true while cnt <= MAX_TRIES
        echo "Unable to get required values from the server"
        return 1
    fi

    #Erase the 'key: ' part from the response
    local masterIp=
    masterIp=$( echo "$response" | sed "s/$MASTER_IP_FIELD: //g" )
    sed -i "s/$PLACECEHOLDER_REPLACEMENT/$masterIp/g" $CONTEXT_FILE 2>/dev/null
    echo
    echo "Replaced the IP placeholder with: $masterIp"
    echo
}

contextualization() {
    marker_file_exists && return 0  # Contextualization has run before

    # Check if the context file has cluster_master inside ucernvm section
    # 'sed' prints all lines  in the [ucernvm-*] section, grep greps the cluster_pin line
    local master_field=
    master_field=$( sed -n '/\[ucernvm-begin\]/,/\[ucernvm-end\]/p' "$AMI_CONTEXT_FILE" 2>/dev/null | grep "$CLUSTER_MASTER_CONTEXT_FIELD=" )

    # erase the first occurence of 'cluster_master=' from the grepped master line
    master_field=$( echo "$master_field" | sed -e "s/$CLUSTER_MASTER_CONTEXT_FIELD=//1" 2>/dev/null )
    if [ "x$master_field" = "xtrue" -o "x$master_field" = "xTrue" -o "x$master_field" = "x1" -o "x$master_field" = "xyes" ]; then
        echo "Doing nothing, this is a master machine"
    else
        slave_contextualization
    fi
    # Create a marker file so the contextualization runs only once
    create_ci_marker_file
}
contextualization # call the main contextualization function
